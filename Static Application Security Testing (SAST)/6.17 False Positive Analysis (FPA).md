# False Positive Analysis (FPA)

## Download the source code

```
git clone https://gitlab.practical-devsecops.training/pdso/dvpa-api
**Output**
Cloning into 'dvpa-api'...
warning: redirecting to https://gitlab.practical-devsecops.training/pdso/dvpa-api.git/
remote: Enumerating objects: 77, done.
remote: Total 77 (delta 0), reused 0 (delta 0), pack-reused 77
Unpacking objects: 100% (77/77), 234.47 KiB | 333.00 KiB/s, done.
```
Let’s cd into the application so we can scan the app.
```
cd dvpa-api
```

## Install Bandit
Let’s install the bandit scanner on the system to perform static analysis.
```
pip3 install bandit==1.7.4
**Ouput**
Collecting bandit==1.7.4
  Downloading bandit-1.7.4-py3-none-any.whl (118 kB)
     |████████████████████████████████| 118 kB 28 kB/s 
Collecting GitPython>=1.0.1
  Downloading GitPython-3.1.27-py3-none-any.whl (181 kB)
     |████████████████████████████████| 181 kB 45.3 MB/s 
Collecting stevedore>=1.20.0
  Downloading stevedore-4.0.0-py3-none-any.whl (49 kB)
     |████████████████████████████████| 49 kB 4.7 MB/s 
Collecting PyYAML>=5.3.1
  Downloading PyYAML-6.0-cp38-cp38-manylinux_2_5_x86_64.manylinux1_x86_64.manylinux_2_12_x86_64.manylinux2010_x86_64.whl (701 kB)
     |████████████████████████████████| 701 kB 39.7 MB/s 
Collecting gitdb<5,>=4.0.1
  Downloading gitdb-4.0.9-py3-none-any.whl (63 kB)
     |████████████████████████████████| 63 kB 928 kB/s 
Collecting pbr!=2.1.0,>=2.0.0
  Downloading pbr-5.9.0-py2.py3-none-any.whl (112 kB)
     |████████████████████████████████| 112 kB 38.9 MB/s 
Collecting smmap<6,>=3.0.1
  Downloading smmap-5.0.0-py3-none-any.whl (24 kB)
Installing collected packages: smmap, gitdb, GitPython, pbr, stevedore, PyYAML, bandit
Successfully installed GitPython-3.1.27 PyYAML-6.0 bandit-1.7.4 gitdb-4.0.9 pbr-5.9.0 smmap-5.0.0 stevedore-4.0.0
```
We have successfully installed Bandit scanner. Let’s explore the functionality it provides us.
```
bandit --help
**Output**
usage: bandit [-h] [-r] [-a {file,vuln}] [-n CONTEXT_LINES] [-c CONFIG_FILE] [-p PROFILE] [-t TESTS] [-s SKIPS]
              [-l | --severity-level {all,low,medium,high}] [-i | --confidence-level {all,low,medium,high}]
              [-f {csv,custom,html,json,screen,txt,xml,yaml}] [--msg-template MSG_TEMPLATE] [-o [OUTPUT_FILE]] [-v]
              [-d] [-q] [--ignore-nosec] [-x EXCLUDED_PATHS] [-b BASELINE] [--ini INI_PATH] [--exit-zero] [--version]
              [targets [targets ...]]

Bandit - a Python source code security analyzer

positional arguments:
  targets               source file(s) or directory(s) to be tested

optional arguments:
  -h, --help            show this help message and exit
  -r, --recursive       find and process files in subdirectories
  -a {file,vuln}, --aggregate {file,vuln}
                        aggregate output by vulnerability (default) or by filename
  -n CONTEXT_LINES, --number CONTEXT_LINES
                        maximum number of code lines to output for each issue
  -c CONFIG_FILE, --configfile CONFIG_FILE
                        optional config file to use for selecting plugins and overriding defaults
  -p PROFILE, --profile PROFILE
                        profile to use (defaults to executing all tests)
  -t TESTS, --tests TESTS
                        comma-separated list of test IDs to run
  -s SKIPS, --skip SKIPS
                        comma-separated list of test IDs to skip
  -l, --level           report only issues of a given severity level or higher (-l for LOW, -ll for MEDIUM, -lll for
                        HIGH)
  --severity-level {all,low,medium,high}
                        report only issues of a given severity level or higher. "all" and "low" are likely to produce
                        the same results, but it is possible for rules to be undefined which will not be listed in
                        "low".
  -i, --confidence      report only issues of a given confidence level or higher (-i for LOW, -ii for MEDIUM, -iii for
                        HIGH)
  --confidence-level {all,low,medium,high}
                        report only issues of a given confidence level or higher. "all" and "low" are likely to
                        produce the same results, but it is possible for rules to be undefined which will not be
                        listed in "low".
  -f {csv,custom,html,json,screen,txt,xml,yaml}, --format {csv,custom,html,json,screen,txt,xml,yaml}
                        specify output format
  --msg-template MSG_TEMPLATE
                        specify output message template (only usable with --format custom), see CUSTOM FORMAT section
                        for list of available values
  -o [OUTPUT_FILE], --output [OUTPUT_FILE]
                        write report to filename
  -v, --verbose         output extra information like excluded and included files
  -d, --debug           turn on debug mode
  -q, --quiet, --silent
                        only show output in the case of an error
  --ignore-nosec        do not skip lines with # nosec comments
  -x EXCLUDED_PATHS, --exclude EXCLUDED_PATHS
                        comma-separated list of paths (glob patterns supported) to exclude from scan (note that these
                        are in addition to the excluded paths provided in the config file) (default:
                        .svn,CVS,.bzr,.hg,.git,__pycache__,.tox,.eggs,*.egg)
  -b BASELINE, --baseline BASELINE
                        path of a baseline report to compare against (only JSON-formatted files are accepted)
  --ini INI_PATH        path to a .bandit file that supplies command line arguments
  --exit-zero           exit with 0, even with results found
  --version             show program's version number and exit

...[SNIP]...
```
--baseline file is important
## Run the scanner
Scan the source code by executing the following command:
```
bandit -r .
**Output**
[main]  INFO    profile include tests: None
[main]  INFO    profile exclude tests: None
[main]  INFO    cli include tests: None
[main]  INFO    cli exclude tests: None
[main]  INFO    running on Python 3.8.10
Run started:2022-08-10 07:07:58.982038

Test results:
>> Issue: [B303:blacklist] Use of insecure MD2, MD4, MD5, or SHA1 hash function.
   Severity: Medium   Confidence: High
   CWE: CWE-327 (https://cwe.mitre.org/data/definitions/327.html)
   Location: ./flaskblog/auth.py:13:23
   More Info: https://bandit.readthedocs.io/en/1.7.4/blacklists/blacklist_calls.html#b303-md5
12          cur = db.connection.cursor()
13          hashsed_password = hashlib.md5(password.encode()).hexdigest()
14          cur.execute(f"SELECT * FROM users WHERE email='{username}' AND password='{hashsed_password}'")

...[SNIP]...

--------------------------------------------------
>> Issue: [B105:hardcoded_password_string] Possible hardcoded password: 'secret'
   Severity: Low   Confidence: Medium
   CWE: CWE-259 (https://cwe.mitre.org/data/definitions/259.html)
   Location: ./flaskblog/config.py:13:11
   More Info: https://bandit.readthedocs.io/en/1.7.4/plugins/b105_hardcoded_password_string.html
12      username = 'admin'
13      password = 'secret'
14
15      # Disqus Configuration
16      disqus_shortname = 'blogpythonlearning'  # please change this.

--------------------------------------------------

Code scanned:
        Total lines of code: 603
        Total lines skipped (#nosec): 0

Run metrics:
        Total issues (by severity):
                Undefined: 0
                Low: 2
                Medium: 11
                High: 0
        Total issues (by confidence):
                Undefined: 0
                Low: 0
                Medium: 9
                High: 4
Files skipped (0):
```
We got 13 issues in total (by severity), but we need to exclude the False Positives.
## False Positive Analysis
There are two ways to do the False Positive Analysis. Either by reading the source code or by exploiting the vulnerability. In this exercise, we only cover the first way.
As per Bandit’s scan results, we have hardcoded password strings, an insecure hash function issue, an insecure deserialization issue, and SQL injection vulnerability.
Let’s try to analyze if they are real issues or false positives. We will try to explore the following three issues among them.
```
>> Issue: [B303:blacklist] Use of insecure MD2, MD4, MD5, or SHA1 hash function.
   Severity: Medium   Confidence: High
   CWE: CWE-327 (https://cwe.mitre.org/data/definitions/327.html)
   Location: ./flaskblog/auth.py:13:23
   More Info: https://bandit.readthedocs.io/en/1.7.4/blacklists/blacklist_calls.html#b303-md5
12          cur = db.connection.cursor()
13          hashsed_password = hashlib.md5(password.encode()).hexdigest()
14          cur.execute(f"SELECT * FROM users WHERE email='{username}' AND password='{hashsed_password}'")

--------------------------------------------------
>> Issue: [B608:hardcoded_sql_expressions] Possible SQL injection vector through string-based query construction.
   Severity: Medium   Confidence: Medium
   CWE: CWE-89 (https://cwe.mitre.org/data/definitions/89.html)
   Location: ./flaskblog/auth.py:14:16
   More Info: https://bandit.readthedocs.io/en/1.7.4/plugins/b608_hardcoded_sql_expressions.html
13          hashsed_password = hashlib.md5(password.encode()).hexdigest()
14          cur.execute(f"SELECT * FROM users WHERE email='{username}' AND password='{hashsed_password}'")
15          user = cur.fetchone()

...[SNIP]...
```
### Analysis of the issues
Let’s explore the first issue now.
```
99              cur = db.connection.cursor()
100             cur.execute(f"UPDATE `users` SET `email` = '{email}', `full_name` = '{full_name}', `phone_number` = '{phone_number}', `dob` = '{dob}' WHERE `users`.`id` = {request.args.get('uid')}")
101             db.connection.commit()
```
It looks like the above code is vulnerable to SQL Injection because uid is used in the query directly, so it’s not a False Positive.
Next, lets check out the second result.
```
             cur.execute(
133                 f"INSERT INTO posts (`body`, `slug`, `author`, `title`) VALUES (%s, %s, %s, %s)",
134                 [body, slug, claim.get("id"), title])
```
The above code is definitely False Positive as we are using Parameter Binding to create the query.
And the last one is a known vulnerability in Python’s YAML library called YAML deserialization. We can search for this known security issue on the CVE website: https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=python%20yaml
```
247                 elif export_format == "yaml":
248                     import_post_data = yaml.load(import_data)
249
```
As mentioned before, our code is vulnerable to Deserialization Attacks and we can mark this as not a False Positive.
## Challenges
In this exericse, you will mark an issue as a False Positive using the bandit’s baseline feature.

We do not recommend you use #nosec as its not a DevSecOps friendly way to mark issues as False Positive for three major reasons.

1. You would have to parse the entire code to list all the False positives (FP).
2. You can’t programatically mark these issues as FP in Vulnerability Management systems like DefectDojo.
3. You can’t create custom criteria to fail a build in maturity level 3 and 4.

**Analyse the results and mark relevant issues as False Positive & Use Bandit feature to perform False Positive as Code**
The baseline file contains issues you would want to mark as False Positives.
This is useful for ignoring known vulnerabilities that you believe are non-issues (e.g. a cleartext password in a unit test).
In layman terms, the issues you want to mark as False Positives, you will add it to this file. The real issues should not be present in this file.
In order to work with baseline feature, you need to generate the baseline.json file using the below command.
```
bandit -r . -f json | tee baseline.json
```
Open the baseline.json file in any text editor of your choice and go to the end of the baseline.json file.
Remove the issues that are NOT false positives from this file and keep the issues that are false positives in it.
Remember we saved the output of the bandit as baseline.json hence all the issues found by Bandit in the previous scan are a part of the baseline.json file. If we do not modify the baseline.json file, and use the baseline.json file as is, then all the issues reported by bandit would be marked as False Positives.
When supplying the baseline.json file, bandit will not report the issues present in the baseline.json file in the subsequent scans.
You can mark the following issue as False positive. How would you do it?

**FPA Video**
```
bandit -r . -f json - o bandit-baseline.json
```
Any issue within this file should be considered as a a false positive 
Then use this file within another run of the scan
```
bandit - r . -f json -o bandit-output.json.json -b bandit-baseline.json
cat bandit-output.json
``` 
Therefore only one issue is being produced as it is not within the baseline file.
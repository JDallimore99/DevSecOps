# Hunting Vulnerability using Semgrep
## Download the source code
Download the source code of the project from our git repository.
```sh
git clone https://gitlab.practical-devsecops.training/pdso/django.nv webapp
**Output**
Cloning into 'webapp'...
warning: redirecting to https://gitlab.practical-devsecops.training/pdso/django.nv.git/
remote: Enumerating objects: 228, done.
remote: Total 228 (delta 0), reused 0 (delta 0), pack-reused 228
Receiving objects: 100% (228/228), 1.03 MiB | 1.04 MiB/s, done.
Resolving deltas: 100% (86/86), done.
```
cd into the application so we can scan the app.
```
cd webapp
```
Now in the webapp directory.
## Install Semgrep
Semgrep is a fast, open-source, static analysis tool that excels at expressing code standards — without complicated queries — and surfacing bugs early in the development flow. Precise rules look like the code you’re searching; no more traversing abstract syntax trees or wrestling with regexes.
You can find more details about the project at https://github.com/returntocorp/semgrep.
Let’s install the Semgrep tool on the system to perform static analysis.
```sh
pip3 install semgrep==0.108.0
**Output**
Collecting semgrep==0.108.0
  Downloading semgrep-0.108.0-cp37.cp38.cp39.py37.py38.py39-none-any.whl (25.2 MB)
     |████████████████████████████████| 25.2 MB 5.0 MB/s 
Collecting colorama~=0.4.0
  Downloading colorama-0.4.5-py2.py3-none-any.whl (16 kB)
Collecting python-lsp-jsonrpc~=1.0.0
  Downloading python_lsp_jsonrpc-1.0.0-py3-none-any.whl (8.5 kB)

...[SNIP]...

Successfully installed attrs-21.4.0 boltons-21.0.0 bracex-2.3.post1 click-8.1.3 click-option-group-0.5.3 colorama-0.4.5 defusedxml-0.7.1 face-20.1.1 glom-22.1.0 importlib-resources-5.9.0 jsonschema-4.9.1 packaging-21.3 peewee-3.15.1 pkgutil-resolve-name-1.3.10 pyparsing-3.0.9 pyrsistent-0.18.1 python-lsp-jsonrpc-1.0.0 ruamel.yaml-0.17.21 ruamel.yaml.clib-0.2.6 semgrep-0.108.0 tqdm-4.64.0 typing-extensions-4.3.0 ujson-5.4.0 urllib3-1.26.11 wcmatch-8.4 zipp-3.8.1
```
We have successfully installed semgrep, let’s explore its functionality now.
```sh
semgrep --help
**Output**
Usage: semgrep [OPTIONS] COMMAND [ARGS]...

  To get started quickly, run `semgrep scan --config auto`

  Run `semgrep SUBCOMMAND --help` for more information on each subcommand

  If no subcommand is passed, will run `scan` subcommand by default

Options:
  -h, --help  Show this message and exit.

Commands:
  ci            The recommended way to run semgrep in CI
  login         Obtain and save credentials for semgrep.dev
  logout        Remove locally stored credentials to semgrep.dev
  lsp           [EXPERIMENTAL] Start the Semgrep LSP server.
  publish       Upload rule to semgrep.dev
  scan          Run semgrep rules on files
  shouldafound  Report a false negative in this project.
```
## Cross-Site Request Forgery (CSRF)
Django applications would be vulnerable to CSRF attack if we’re using csrf_exempt decorator or django.middleware.csrf.CsrfViewMiddleware middleware is not set in MIDDLEWARE_CLASSES, we can use Semgrep to find those things to mitigate the CSRF vulnerability.
```sh
cat > csrf_hunting.yaml <<EOF
rules:
- id: possible-csrf
  patterns:
  - pattern-inside: | 
      @csrf_exempt
      def \$FUNC(\$X):
          ...
  message: |
    Possible CSRF
  languages:
  - python
  severity: WARNING

- id: no-csrf-middleware
  patterns:
  - pattern: MIDDLEWARE_CLASSES=(...)
  - pattern-not: MIDDLEWARE_CLASSES=(...,'django.middleware.csrf.CsrfViewMiddleware',...)
  message: |
    No CSRF middleware
  languages:
  - python
  severity: WARNING
EOF
```
There are 2 rules in YAML file.
1. possible-csrf: Find all function definitions that use @csrf_exempt as decorator
2. no-csrf-middleware: Search the string MIDDLEWARE_CLASSES and see if doesn’t have ‘django.middleware.csrf.CsrfViewMiddleware’ on it

Run Semgrep with our rules against the source code.
```
semgrep -f csrf_hunting.yaml .
**Output**
Scanning 50 files with 2 python rules.
  100%|█████████████████████████████████████████████████████████████████████████████████████████████████████|50/50 tasks

Findings:

  taskManager/views.py 
     possible-csrf
        Possible CSRF

        739┆ @csrf_exempt
        740┆ def reset_password(request):
        741┆ 
        742┆     if request.method == 'POST':
        743┆ 
        744┆         reset_token = request.POST.get('reset_token')
        745┆ 
        746┆         try:
        747┆             userprofile = UserProfile.objects.get(reset_token = reset_token)
        748┆             if timezone.now() > userprofile.reset_token_expiration:
           [hid 27 additional lines, adjust with --max-lines-per-finding] 
        779┆ @csrf_exempt
        780┆ def forgot_password(request):
        781┆ 
        782┆     if request.method == 'POST':
        783┆         t_email = request.POST.get('email')
        784┆ 
        785┆         try:
        786┆             reset_user = User.objects.get(email=t_email)
        787┆ 
        788┆             # Generate secure random 6 digit number
           [hid 21 additional lines, adjust with --max-lines-per-finding] 
        813┆ @csrf_exempt
        814┆ def change_password(request):
        815┆ 
        816┆     if request.method == 'POST':
        817┆         user = request.user
        818┆         old_password = request.POST.get('old_password')
        819┆         new_password = request.POST.get('new_password')
        820┆         confirm_password = request.POST.get('confirm_password')
        821┆ 
        822┆         if authenticate(username=user.username, password=old_password):
           [hid 12 additional lines, adjust with --max-lines-per-finding] 

Some files were skipped or only partially analyzed.
  Scan was limited to files tracked by git.

Ran 2 rules on 50 files: 3 findings.
```
As you can see, we found three functions where CSRF vulnerability can be exploited.
## Misconfigurations
Security misconfiguration is a class of vulnerability that occurs when the software is set up incorrectly, left insecure and can happen at any level of an application stack including the platform, web server, application server, database, framework, or any custom code.
Source: OWASP Top 10 https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration

Let’s create a rule to hunt misconfigurations in our application e.g., availability of DEBUG=True flag in settings.py file.
```sh
cat > debug_enable.yaml <<EOF 
rules:
- id: debug-enabled
  patterns:
  - pattern: DEBUG=True
  message: |
    Detected Django app with DEBUG=True. Do not deploy to production with this flag enabled
    as it will leak sensitive information.
  metadata:
    cwe: 'CWE-489: Active Debug Code'
    owasp: 'A6: Security Misconfiguration'
    references:
    - https://blog.scrt.ch/2018/08/24/remote-code-execution-on-a-facebook-server/
  severity: WARNING
  languages:
  - python
EOF
```
Run Semgrep with our rules in the source code.
```sh
semgrep -f debug_enable.yaml .
**Output**
Scanning 50 files.
  100%|█████████████████████████████████████████████████████████████████████████████████████████████████████|50/50 tasks

Findings:

  taskManager/settings.py 
     debug-enabled
        Detected Django app with DEBUG=True. Do not deploy to production with this flag enabled as
        it will leak sensitive information.

         28┆ DEBUG = True

Some files were skipped or only partially analyzed.
  Scan was limited to files tracked by git.

Ran 1 rule on 50 files: 1 finding.
```
We scanned about 51 files and found 1 security issue.
## Ported Security Tools Ruleset
Semgrep’s team converted the security rulesets from different tools like bandit, gosec, nodejsscan, findsecbugs, or eslint-plugin-security into Semgrep rules. Let use these rulesets to scan our application.

We will use the Bandit ruleset for semgrep in this section.
```sh
semgrep --config "p/bandit" .
**Output**
Scanning 50 files with 61 python rules.
  100%|█████████████████████████████████████████████████████████████████████████████████████████████████████|50/50 tasks

Findings:

  taskManager/misc.py 
     python.lang.security.audit.dangerous-system-call.dangerous-system-call
        Found dynamic content used in a system call. This is dangerous if external data can reach
        this function call because it allows a malicious actor to execute commands. Use the
        'subprocess' module instead, which is easier to use without accidentally exposing a command
        injection vulnerability.
        Details: https://sg.run/vzKA

         33┆ os.system(
         34┆     "mv " +
         35┆     uploaded_file.temporary_file_path() +
         36┆     " " +
         37┆     "%s/%s" %
         38┆     (upload_dir_path,
         39┆      title))


  taskManager/views.py 
     python.lang.security.audit.formatted-sql-query.formatted-sql-query
        Detected possible formatted SQL query. Use parameterized queries instead.
        Details: https://sg.run/EkWw

        183┆ curs.execute(
        184┆     "insert into taskManager_file ('name','path','project_id') values ('%s','%s',%s)" %
        185┆     (name, upload_path, project_id))

Some files were skipped or only partially analyzed.
  Scan was limited to files tracked by git.

Ran 61 rules on 50 files: 2 findings.
```
Semgrep ran 61 rules from bandit rulesets and found 2 vulnerabilities, so we don’t rely on predefined rules.

Did it miss any vulnerabilities which bandit found? If so, why?
https://r2c.dev/blog/2021/python-static-analysis-comparison-bandit-semgrep/#:~:text=Bandit%20and%20Semgrep%20using%20p%2Fgitlab-bandit%20report%20mostly%20the,reported%20by%20Bandit%20and%20p%2Fgitlab-bandit%20were%20the%20same.
